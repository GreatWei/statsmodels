# coding: utf-8

# DO NOT EDIT
# Autogenerated from the notebook statespace_structural_harvey_jaeger.ipynb.
# Edit the notebook and then sync the output with this file.
#
# flake8: noqa
# DO NOT EDIT

# # 去趋势化， 典型事实与商业周期
#
# 在有影响力的文章中，Harvey 和 Jaeger（1993）描述了使用未观测到的组件模型（也称为“结构时间序列模型”）来得出商业周期性的典型事实。
#
# 他们的论文开始:
# 
#     “ 'stylized facts' 与一系列时间序列建立相关，被广泛认为是至关重要的一步。在宏观经济研究中，为了使此类事实有用，
# 它们应（1）与随机变量保持一致数据的属性，以及（2）提供有意义的信息。”

# 尤其是，他们提出这样的论点，通常使用未观测到的组件方法可以更好地实现这些目标，而不是使用流行的 Hodrick-Prescott 滤波器
# 或 Box-Jenkins ARIMA 建模技术。

# statsmodels 能够实现这三种类型的分析，下面我们将使用稍有更新的数据集按照其论文的步骤进行操作。


import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt

from IPython.display import display, Latex

# ## 未观测到的组件
#
# 在 statsmodels 中未观察到的组件模型可供使用，并写成：
#
# $$
# y_t = \underbrace{\mu_{t}}_{\text{trend}} +
# \underbrace{\gamma_{t}}_{\text{seasonal}} +
# \underbrace{c_{t}}_{\text{cycle}} + \sum_{j=1}^k \underbrace{\beta_j
# x_{jt}}_{\text{explanatory}} +
# \underbrace{\varepsilon_t}_{\text{irregular}}
# $$
#
# 有关注释和其他详细信息，请参见 Durbin 和 Koopman 2012，第3章。 请注意，针对不同的单个组件的不同规格可以支持各种型号。
# 论文认为特定模型，是下文专业的通用方程。
#
# ### 趋势性
#
# 趋势组件是包含截距和线性时间趋势的回归模型的动态扩展。
#
# $$
# \begin{align}
# \underbrace{\mu_{t+1}}_{\text{level}} & = \mu_t + \nu_t + \eta_{t+1}
# \qquad & \eta_{t+1} \sim N(0, \sigma_\eta^2) \\\\
# \underbrace{\nu_{t+1}}_{\text{trend}} & = \nu_t + \zeta_{t+1} &
# \zeta_{t+1} \sim N(0, \sigma_\zeta^2) \\
# \end{align}
# $$
#
# 其中水平是截距的一般化，可以随时间动态变化，趋势是一般化的时间趋势，使得斜率可以随时间动态变化。
#
# 对于两个元素（水平和趋势），我们可以考虑以下模型：:
#
# - 元素包括还是不包括（如果包括趋势，则还必须包括水平）。
# - 元素是确定性还是随机性（即误差项的方差是否限制为零）
#
# 估计唯一附加的参数是通过 MLE 来估计，是任何包含的随机成分的方差。
#
# 遵循以下规范:
#
# |                                                                      |
# Level | Trend | Stochastic Level | Stochastic Trend |
# |----------------------------------------------------------------------|
# -------|-------|------------------|------------------|
# | Constant                                                             |
# ✓     |       |                  |                  |
# | Local Level <br /> (random walk)                                     |
# ✓     |       | ✓                |                  |
# | Deterministic trend                                                  |
# ✓     | ✓     |                  |                  |
# | Local level with deterministic trend <br /> (random walk with drift) |
# ✓     | ✓     | ✓                |                  |
# | Local linear trend                                                   |
# ✓     | ✓     | ✓                | ✓                |
# | Smooth trend <br /> (integrated random walk)                         |
# ✓     | ✓     |                  | ✓                |
#
# ### 季节性
#
# 季节性可以写成:
#
# <span>$$
# \gamma_t = - \sum_{j=1}^{s-1} \gamma_{t+1-j} + \omega_t \qquad \omega_t
# \sim N(0, \sigma_\omega^2)
# $$</span>
#
# 周期性（number of seasons）为 `s`，定义 character 为（无误差项）：在一个完整的周期中，季节性因子的总和为零。
# 包含误差项可以使季节性影响随时间变化。
#
# 此模型的变体是:
#
# - 周期性 `s`
# - 是否使季节性影响随机.
#
# 如果季节性影响是随机的，则可以通过 MLE（误差项的方差）估算一个附加参数。
#
# ### 周期性
#
# 周期性因子旨在捕获周期性影响，在时间范围内比季节性因子所捕获的更长。 例如，在经济学中，周期性通常是指旨在捕获的商业周期，
# 并预测其周期为 “1.5至12年” （请参见 Durbin 和 Koopman ）。
#
# 周期性可以写成:
#
# <span>$$
# \begin{align}
# c_{t+1} & = c_t \cos \lambda_c + c_t^* \sin \lambda_c + \tilde \omega_t
# \qquad & \tilde \omega_t \sim N(0, \sigma_{\tilde \omega}^2) \\\\
# c_{t+1}^* & = -c_t \sin \lambda_c + c_t^* \cos \lambda_c + \tilde
# \omega_t^* & \tilde \omega_t^* \sim N(0, \sigma_{\tilde \omega}^2)
# \end{align}
# $$</span>
#
# 参数 $\lambda_c$ （周期性的频率）是 MLE 估计的附加参数。 如果季节性影响是随机的，则可以使用另一个参数进行估计
# （误差项的方差-注意这两个误差项具有相同的方差，但我们假定误差项具有独立的）。
#
# ### Irregular
#
# 假设不规则成分是白噪声误差项。 它的方差是 MLE 估计的参数； 即
#
# $$
# \varepsilon_t \sim N(0, \sigma_\varepsilon^2)
# $$
#
# 在某些情况下，我们可能想对不规则成分进行泛化以考虑自回归效应：
#
# $$
# \varepsilon_t = \rho(L) \varepsilon_{t-1} + \epsilon_t, \qquad
# \epsilon_t \sim N(0, \sigma_\epsilon^2)
# $$
#
# 在这种情况下，还将通过 MLE 来估计自回归参数。
#
# ### 回归效应
#
# 我们可能想要通过附加项
#
# <span>$$
# \sum_{j=1}^k \beta_j x_{jt}
# $$</span>
#
# 来允许解释变量或为了干预效果通过
#
# <span>$$
# \begin{align}
# \delta w_t \qquad \text{where} \qquad w_t & = 0, \qquad t < \tau, \\\\
# & = 1, \qquad t \ge \tau
# \end{align}
# $$</span>
#
# 这些附加参数可以通过 MLE 来估算，也可以通过将其作为状态空间公式的组成部分来估算。
#

# ## 数据
#
# 继 Harvey 和 Jaeger 之后，我们认为以下时间序列是:
#
# - 美国实际国民生产总值, "output",
# ([GNPC96](https://research.stlouisfed.org/fred2/series/GNPC96))
# - 美国国民生产总值的隐性物价平缓指数, "prices",
# ([GNPDEF](https://research.stlouisfed.org/fred2/series/GNPDEF))
# - 美国货币基础, "money",
# ([AMBSL](https://research.stlouisfed.org/fred2/series/AMBSL))
#
# 与原始论文中的时间范围 serises 有异，但大致是 1954-1989 年。 下面我们使用所有 series 是来自 1948-2008 年的数据。 
# 尽管未观测到组件的方法允许在模型中剥离季节性成分，但是，在这里本文的 series 已经做了季节性调整。
# 
#
# 这里研究的所有数据系列均来自[Federal Reserve Economic Data（FRED）]（https://research.stlouisfed.org/fred2/）。 
# 更加便捷的是，Python 的 [Pandas] 库（http://pandas.pydata.org/）可以直接从 FRED 加载数据。


# 数据集
from pandas_datareader.data import DataReader

# 获取原始数据
start = '1948-01'
end = '2008-01'
us_gnp = DataReader('GNPC96', 'fred', start=start, end=end)
us_gnp_deflator = DataReader('GNPDEF', 'fred', start=start, end=end)
us_monetary_base = DataReader(
    'AMBSL', 'fred', start=start, end=end).resample('QS').mean()
recessions = DataReader(
    'USRECQ', 'fred', start=start, end=end).resample('QS').last().values[:, 0]

# 组合 DataFrame
dta = pd.concat(
    map(np.log, (us_gnp, us_gnp_deflator, us_monetary_base)), axis=1)
dta.columns = ['US GNP', 'US Prices', 'US monetary base']
dates = dta.index._mpl_repr()

# 为了理解对时间范围内的这三个变量，绘图：

# 数据绘图
ax = dta.plot(figsize=(13, 3))
ylim = ax.get_ylim()
ax.xaxis.grid()
ax.fill_between(
    dates,
    ylim[0] + 1e-5,
    ylim[1] - 1e-5,
    recessions,
    facecolor='k',
    alpha=0.1)

# ## 模型
#
# 由于数据已经做了季节性调整，并且没有明显的解释变量，因此考虑的通用模型为
#
# $$
# y_t = \underbrace{\mu_{t}}_{\text{trend}} +
# \underbrace{c_{t}}_{\text{cycle}} +
# \underbrace{\varepsilon_t}_{\text{irregular}}
# $$
#
# 不规则成分将被认为是白噪声，并且周期性将是随机的和衰减的。 最终的建模选择是使用趋势组件的规范。 Harvey 和 Jaeger 考虑了两种模型：
#
# 1. 局部线性趋势 ( "unrestricted" 模型)
# 2. 平滑趋势 ( "restricted" 模型, 因为我们面临 $\sigma_\eta = 0$ 的情况)
#
# 下面，我们为每种模型类型构造 `kwargs` 字典。 请注意，有两种方法可以指定模型。一种方法是直接指定组件，如上表所示。
# 另一种方法是使用字符名称映射到各种规范。


# 模型规范

# 不受限制模型，使用字符规范
unrestricted_model = {
    'level': 'local linear trend',
    'cycle': True,
    'damped_cycle': True,
    'stochastic_cycle': True
}

# 不受限制模型，直接设置组件
# 这是一种等效的但不是很便捷的方法，用于指定一个带有随机阻尼周期的局部线性趋势模型
# unrestricted_model = {
#     'irregular': True, 'level': True, 'stochastic_level': True, 'trend':
# True, 'stochastic_trend': True,
#     'cycle': True, 'damped_cycle': True, 'stochastic_cycle': True
# }

# 受限制模型强加一个平滑趋势
restricted_model = {
    'level': 'smooth trend',
    'cycle': True,
    'damped_cycle': True,
    'stochastic_cycle': True
}

# 受限制模型，直接设置组件
# 这是一种等效的但不是很便捷的方法，用于指定一个带有随机阻尼周期的平滑趋势模型，注意与局部线性趋势模型的不同之处是 `stochastic_level=False` 。
# unrestricted_model = {
#     'irregular': True, 'level': True, 'stochastic_level': False,
# 'trend': True, 'stochastic_trend': True,
#     'cycle': True, 'damped_cycle': True, 'stochastic_cycle': True
# }

# 现在我们拟合下列模型:
#
# 1. Output, unrestricted model不受限制模型
# 2. Prices, unrestricted model不受限制模型
# 3. Prices, restricted model受限制模型
# 4. Money, unrestricted model不受限制模型
# 5. Money, restricted model受限制模型

# Output
output_mod = sm.tsa.UnobservedComponents(dta['US GNP'], **unrestricted_model)
output_res = output_mod.fit(method='powell', disp=False)

# Prices
prices_mod = sm.tsa.UnobservedComponents(dta['US Prices'],
                                         **unrestricted_model)
prices_res = prices_mod.fit(method='powell', disp=False)

prices_restricted_mod = sm.tsa.UnobservedComponents(dta['US Prices'],
                                                    **restricted_model)
prices_restricted_res = prices_restricted_mod.fit(method='powell', disp=False)

# Money
money_mod = sm.tsa.UnobservedComponents(dta['US monetary base'],
                                        **unrestricted_model)
money_res = money_mod.fit(method='powell', disp=False)

money_restricted_mod = sm.tsa.UnobservedComponents(dta['US monetary base'],
                                                   **restricted_model)
money_restricted_res = money_restricted_mod.fit(method='powell', disp=False)

# 一旦我们拟合了这些模型，就可以通过多种方式展示信息。 查看美国国民生产总值模型，我们可以使用 `summary` 方法对拟合对象进行模型拟合。


print(output_res.summary())

# 对于未观测到组件模型，尤其是在引言中的第（2）点探索 stylized facts 时，更有用的方法通常是绘制估计未观测到的组件（例如水平，趋势和周期），
# 来查看它们是否提供有意义的数据描述。
#
# 拟合对象的 `plot_components` 方法可用于展示每个估计状态的曲线和置信区间，以及观测到的数据图与模型逐步预测进行比较，来评估拟合。


fig = output_res.plot_components(
    legend_loc='lower right', figsize=(15, 9))

# 最后，Harvey 和 Jaeger 以另一种方式总结了模型，用以强调趋势性和周期性成分的相对重要性。 下面我们复制表 I。
# 我们发现所有的值大致上与它们表中的值一致，但在细节上略有不同。
# 
# 创建表 I
table_i = np.zeros((5, 6))

start = dta.index[0]
end = dta.index[-1]
time_range = '%d:%d-%d:%d' % (start.year, start.quarter, end.year, end.quarter)
models = [
    ('US GNP', time_range, 'None'),
    ('US Prices', time_range, 'None'),
    ('US Prices', time_range, r'$\sigma_\eta^2 = 0$'),
    ('US monetary base', time_range, 'None'),
    ('US monetary base', time_range, r'$\sigma_\eta^2 = 0$'),
]
index = pd.MultiIndex.from_tuples(
    models, names=['Series', 'Time range', 'Restrictions'])
parameter_symbols = [
    r'$\sigma_\zeta^2$',
    r'$\sigma_\eta^2$',
    r'$\sigma_\kappa^2$',
    r'$\rho$',
    r'$2 \pi / \lambda_c$',
    r'$\sigma_\varepsilon^2$',
]

i = 0
for res in (output_res, prices_res, prices_restricted_res, money_res,
            money_restricted_res):
    if res.model.stochastic_level:
        (sigma_irregular, sigma_level, sigma_trend, sigma_cycle,
         frequency_cycle, damping_cycle) = res.params
    else:
        (sigma_irregular, sigma_level, sigma_cycle, frequency_cycle,
         damping_cycle) = res.params
        sigma_trend = np.nan
    period_cycle = 2 * np.pi / frequency_cycle

    table_i[i, :] = [
        sigma_level * 1e7, sigma_trend * 1e7, sigma_cycle * 1e7, damping_cycle,
        period_cycle, sigma_irregular * 1e7
    ]
    i += 1

pd.set_option('float_format',
              lambda x: '%.4g' % np.round(x, 2) if not np.isnan(x) else '-')
table_i = pd.DataFrame(table_i, index=index, columns=parameter_symbols)
table_i
