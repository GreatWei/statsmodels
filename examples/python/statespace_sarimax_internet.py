# coding: utf-8

# DO NOT EDIT
# Autogenerated from the notebook statespace_sarimax_internet.ipynb.
# Edit the notebook and then sync the output with this file.
#
# flake8: noqa
# DO NOT EDIT

# # SARIMAX: 模型选择, 缺失值

# 这个示例反映了 Durbin 和 Koopman（2012）第 8.4 章，应用 Box-Jenkins 方法论来拟合 ARMA 模型。 
# 这种方法论的新颖特点是模型能够处理带有缺少值的数据集。


import numpy as np
import pandas as pd
from scipy.stats import norm
import statsmodels.api as sm
import matplotlib.pyplot as plt

import requests
from io import BytesIO
from zipfile import ZipFile

# 加载数据集
dk = requests.get('http://www.ssfpack.com/files/DK-data.zip').content
f = BytesIO(dk)
zipped = ZipFile(f)
df = pd.read_table(
    BytesIO(zipped.read('internet.dat')),
    skiprows=1,
    header=None,
    sep='\s+',
    engine='python',
    names=['internet', 'dinternet'])

# ### 模型选择
#
# 在 Durbin 和 Koopman 模型中，我们需要面对许多缺失值。


# 基础系列
dta_full = df.dinternet[1:].values
dta_miss = dta_full.copy()

# 删除数据点
missing = np.r_[6, 16, 26, 36, 46, 56, 66, 72, 73, 74, 75, 76, 86, 96] - 1
dta_miss[missing] = np.nan

# 然后，我们可以考虑使用 Akaike 信息标准（AIC）进行模型选择，但为每个变体运行模型和选择带有最低 AIC 值的模型
#
# 有几件事要注意：
#
# -在运行如此大量的模型时，尤其是当自回归和多阶移动平均变大时，极大似然的收敛可能会很差。 
#  由于只是说明性的示例，因此我们忽略警告。

# -我们使用 `enforce_invertibility=False` 选项，这个选项可以使移动平均多项式不可逆，为的就是可以估计更多模型。

# -某些模型效果不佳，其 AIC 值设置为 NaN。 这并不奇怪，因为 Durbin 和 Koopman 指出了高阶模型的数值问题。

import warnings

aic_full = pd.DataFrame(np.zeros((6, 6), dtype=float))
aic_miss = pd.DataFrame(np.zeros((6, 6), dtype=float))

warnings.simplefilter('ignore')

# 在 [0,6] 之间，迭代所有的 ARMA(p,q) 模型
for p in range(6):
    for q in range(6):
        if p == 0 and q == 0:
            continue

        # 估计没有缺少数据点的模型
        mod = sm.tsa.statespace.SARIMAX(
            dta_full, order=(p, 0, q), enforce_invertibility=False)
        try:
            res = mod.fit(disp=False)
            aic_full.iloc[p, q] = res.aic
        except:
            aic_full.iloc[p, q] = np.nan

        # 估计缺少数据点的模型
        mod = sm.tsa.statespace.SARIMAX(
            dta_miss, order=(p, 0, q), enforce_invertibility=False)
        try:
            res = mod.fit(disp=False)
            aic_miss.iloc[p, q] = res.aic
        except:
            aic_miss.iloc[p, q] = np.nan

# 对于在完整（非缺失）数据集上估计的模型，AIC 选择 ARMA(1,1) 或 ARMA(3,0)。Durbin 和 Koopman 
# 认为 ARMA(1,1) 模型的规范性会更好，因为模型更加简约。
#
# $$
# \text{Replication of:}\\
# \textbf{Table 8.1} ~~ \text{AIC for different ARMA models.}\\
# \newcommand{\r}[1]{{\color{red}{#1}}}
# \begin{array}{lrrrrrr}
# \hline
# q &      0 &      1 &      2 &      3 &      4 &      5 \\
# \hline
# p &     {} &     {} &     {} &     {} &     {} &     {} \\
# 0 &   0.00 & 549.81 & 519.87 & 520.27 & 519.38 & 518.86 \\
# 1 & 529.24 & \r{514.30} & 516.25 & 514.58 & 515.10 & 516.28 \\
# 2 & 522.18 & 516.29 & 517.16 & 515.77 & 513.24 & 514.73 \\
# 3 & \r{511.99} & 513.94 & 515.92 & 512.06 & 513.72 & 514.50 \\
# 4 & 513.93 & 512.89 &    nan &    nan & 514.81 & 516.08 \\
# 5 & 515.86 & 517.64 &    nan &    nan &    nan &    nan \\
# \hline
# \end{array}
# $$
#
# 对于缺失数据集上估计的模型，AIC 选择 ARMA(1,1)
#
# $$
# \text{Replication of:}\\
# \textbf{Table 8.2} ~~ \text{AIC for different ARMA models with missing
# observations.}\\
# \begin{array}{lrrrrrr}
# \hline
# q &      0 &      1 &      2 &      3 &      4 &      5 \\
# \hline
# p &     {} &     {} &     {} &     {} &     {} &     {} \\
# 0 &   0.00 & 488.93 & 464.01 & 463.86 & 462.63 & 463.62 \\
# 1 & 468.01 & \r{457.54} & 459.35 & 458.66 & 459.15 & 461.01 \\
# 2 & 469.68 &    nan & 460.48 & 459.43 & 459.23 & 460.47 \\
# 3 & 467.10 & 458.44 & 459.64 & 456.66 & 459.54 & 460.05 \\
# 4 & 469.00 & 459.52 &    nan & 463.04 & 459.35 & 460.96 \\
# 5 & 471.32 & 461.26 &    nan &    nan & 461.00 & 462.97 \\
# \hline
# \end{array}
# $$
#
# **注意**：AIC 值的计算方法与 Durbin 和 Koopman 中的计算方法不同，但总体上显示出相似的趋势。 


# ### 后估计
#
# 上面我们选择了 ARMA(1,1) 模型的规范，我们做了样本内预测和样本外预测。


# 状态空间
mod = sm.tsa.statespace.SARIMAX(dta_miss, order=(1, 0, 1))
res = mod.fit(disp=False)
print(res.summary())

# 样本内逐步预测和样本外预测

nforecast = 20
predict = res.get_prediction(end=mod.nobs + nforecast)
idx = np.arange(len(predict.predicted_mean))
predict_ci = predict.conf_int(alpha=0.5)

# 绘图
fig, ax = plt.subplots(figsize=(12, 6))
ax.xaxis.grid()
ax.plot(dta_miss, 'k.')

# 图
ax.plot(idx[:-nforecast], predict.predicted_mean[:-nforecast], 'gray')
ax.plot(
    idx[-nforecast:],
    predict.predicted_mean[-nforecast:],
    'k--',
    linestyle='--',
    linewidth=2)
ax.fill_between(idx, predict_ci[:, 0], predict_ci[:, 1], alpha=0.15)

ax.set(title='Figure 8.9 - Internet series')
